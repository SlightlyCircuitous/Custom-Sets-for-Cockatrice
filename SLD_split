import xml.etree.ElementTree as ET

def SLD_split(cards_xml, card_names, sets_data, output_name):
    """
    Searches a given xml file of MTG cards for cards in card_names and uses them to create
    a new set described by sets_data. Removes non-SLD set information and renames SLD set. 
    Writes to a new XML file.
    
    :param cards_xml: the cards.xml file generated by Cockatrice
    :param card_names: a list of card names in the set to be created
    :param sets_data: a dict {name:four-letter set code, longname:full set name,releasedate:YYYY-MM-DD}
    :param output_name: the file to write to with no extension
    
    :returns: a list of collector numbers (to check that the right cards made it in)
    """
    
    #parse the XML and get the root to use in search
    #(either .append or .remove seemingly links removal in old and new trees so reparsing is needed for multiple runs)
    
    tree = ET.parse(cards_xml)
    root = tree.getroot()
    
    #check if custom set name conflicts with existing 4-letter sets
    set_set = set([coll.text for coll in root.findall("./cards/card/set")])
    ban_list = [item for item in set_set if len(item) == 4 and item[3] == 'D']
    if sets_data['name'] in ban_list:
        return "Set name conflicts with extant set. No file created."
    
    #make the header and set info
    
    new_root = ET.Element('cockatrice_carddatabase', attrib={'version': "4"})
    sets = ET.SubElement(new_root, 'sets')
    a_set = ET.SubElement(sets, 'set')
    ET.SubElement(a_set, 'name').text = sets_data['name']
    ET.SubElement(a_set, 'longname').text = sets_data['longname'] + ' Drop'
    ET.SubElement(a_set, 'settype').text = 'Custom'
    ET.SubElement(a_set, 'releasedate').text = sets_data['releasedate']
    cards = ET.SubElement(new_root, 'cards')
    
    trans_list = [] #possibly needed list for transform card backsides
    
    #search for cards and write results to file
    
    for card in root.findall('./cards/card'): #specific to the structure of cards.xml
        
        front_name = card.find('name').text
        
        if front_name in card_names:
            
            cards.append(card) #appends card element as child of cards
            
            #check to see if any cards transform so the back face art can be included
            
            node = card.find('./related[@attach="transform"]')
            
            if node is not None: #check for an exisiting 'related' element
                
                trans_face = node.text
            
                for trans_card in root.findall('./cards/card'): 
        
                    if trans_card.find('name').text == trans_face:
            
                        trans_list.append(trans_card) #appends card element as child of cards
                          
    cards.extend(trans_list) #add in the transform backsides
            
    #remove non-SLD set information and changes SLD set to sets_data['name']
    
    for elem in new_root.findall('./cards/card'):
        
        for child in list(elem): #list(elem) lists all subelements of elem
            
            if child.tag == 'set' and child.text != 'SLD': #either/or would delete a lot of lines
                
                elem.remove(child) #.remove needs to be pointed *directly* at what it removes
                
        elem.find('set').text = sets_data['name'] #changes set text to new name
        
    #clean up and write to file    
    
    new_tree = ET.ElementTree(new_root) #puts the xml tree into a class
    ET.indent(new_tree, space='    ') #puts in all the nice whitespace
    new_tree.write(output_name+'.xml',encoding='utf-8', xml_declaration=True) #writes using a class method
    
    #Mention transform cards if needed
    
    trans_len = len(trans_list)
    
    if trans_len != 0:
        
        print(f"Included backside art for {trans_len} cards that can transform.")
    
    #return set of collector numbers for checking which art is referenced; this removes duplicates from transformed cards
    
    return sorted(set(int(coll.attrib['num']) for coll in new_root.findall("./cards/card/set")))
